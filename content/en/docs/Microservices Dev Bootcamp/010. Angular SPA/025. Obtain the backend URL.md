---
type: docs
title: "Obtain the backend URL"
linkTitle: "Obtain the backend URL"
weight: 30
description: >
  Who you gonna call?
---

This stuff came from https://www.thisdot.co/blog/runtime-environment-configuration-with-angular

### Overview

We're going to create a service, `ConfigService`, which:
 - Uses an `HttpClient`.
 - Reads, at runtime, values from a file `config.json`.

`config.json` will start with some default values but will be overwritten by the
pipeline to contain the appropriate values for the environment in which
the site is running.

### Create feature branch

feature/obtain-backend-url

### assets/config.json

Create `assets/config.json`. (The assets folder contains static assets which will be copied 
into our final static site.)
~~~
{
  "apiUrl": "/api"
}
~~~

Commit with comment "assets/config.json"

### ConfigService and Config class

Generate some code. Note that our `Config` class is a just a DTO and doesn't need
automated tests, so we use the `--skip-tests=true` option.

~~~
npx ng generate service core/singleton-services/config/config
npx ng generate class core/singleton-services/config/config --skip-tests=true
~~~

At this point we'd inspect the changes made to:

~~~
src\app\core\singleton-services\config\config.service.spec.ts
src\app\core\singleton-services\config\config.service.ts
src\app\core\singleton-services\config\config.ts
~~~

Commit with comment "ng g class & service config config"

Edit `config.ts`:
~~~
export class Config {
  apiUrl: string | undefined;
}
~~~

Edit `config.service.ts` to add `HttpClient` to the constructor:

~~~
export class ConfigService {

  constructor(private httpClient: HttpClient) { }
}
~~~

Notice that you now have a failing test. That's because `config.service.spec.ts`
doesn't know yet how to provide the `HttpClient`.

Add an `HttpClientTestingModule` to the `imports` in `config.service.spec.ts` like this:
~~~
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule]
    });
    service = TestBed.inject(ConfigService);
  });
~~~

Now your tests should be happy again.

Create a stub for our implementation code and provide a test for it.
The test will initially fail, of course, and that's good.

In `config.service.ts`:

~~~
export class ConfigService {
  public config!: Config;

  constructor(private httpClient: HttpClient) { }

  loadConfig(): Config {
    return this.config; // TODO: Read from file
  }
}
~~~

In `config.service.spec.ts`:

~~~
...

  it('should provide default values', () => {
    const config = service.loadConfig();
    expect(config.apiUrl).toBe('/api');
  });
});
~~~

At this point you should have a failing test like this:

~~~
ConfigService > should provide default values

Expected undefined to be '/api'.
~~~

That's good!

Commit with comment "Wrote stub for ConfigService.loadConfig()"

Let's provide the proper implementation in `config.service.ts` so the test passes.

~~~
~~~
